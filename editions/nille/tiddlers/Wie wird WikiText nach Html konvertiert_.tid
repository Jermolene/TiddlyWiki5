created: 20191011110140105
modified: 20191019224347751
tags: 
title: Wie wird WikiText nach Html konvertiert?
type: text/vnd.tiddlywiki

<!-- Intro-->

WikiText besteht zum einen aus [[Syntax-Elementen|https://de.wikipedia.org/wiki/Syntax]] die eine [[Markdown|https://de.wikipedia.org/wiki/Markdown]]-ähnliche Natur haben. Das schließt auch die Syntax von [[Makros|Macros]] -- `<<...>>` -- und [[Transklusionen|Transclusion in WikiText]] -- `{{...}}` -- mit ein. ~WikiText kann aber auch beliebig verschachtelte Html-Konstrukte enthalten -- [[Standard-HTML|https://www.w3schools.com/html/html_intro.asp]], die hauseigenen [[Widgets]], andere Dialekte wie [[SVG|https://inkscape.org/de/entwickeln/das-svg-format/]], ja, jeder benutzerdefinierte Element-Name ist erlaubt.

Man kann diese zwei verschiedenen Syntaxen frei mischen, daraus resultieren jedoch einige Syntax-Regeln, insbesondere in Bezug auf [[automatisch erzeugte Textabsätze|Automatisch erzeugte Textabsätze]], die man einhalten muss, um das gewünschte Resultat, sprich [[valides Html|Valides Html]] zu erhalten. Wir sprechen insbesondere von der Funktion die Zeilenumbrüche im WikiText haben. 

Diese Syntax-Regeln werden Wir jetzt anhand der Funktionsweise des Wikiparsers betrachten.

Hinweis: Im Nachfolgenden gibt es zu __unterstrichenen Worten__ in Haupttext in der Seitenleiste nähere Erläuterungen.


<!-- ! Der Wikiparser-->

! Der Wikiparser

<!-- <aside class="info">-->

<aside class="info">

//[[Javascript|https://www.w3schools.com/js/]]-[[Quellcode des Wikiparsers|https://github.com/Jermolene/TiddlyWiki5/tree/master/core/modules/parsers/wikiparser]]//.  Der Parser ist im Modul `wikiparser.js` definiert. das Modul `wikirulebase.js` definiert den [[Prototyp|https://de.wikipedia.org/wiki/Basisklasse]] für //Regeln//, die wir weiter unten erklären werden. Im Ordner `rules` befinden sich die konkreten Regeln, die von `wikirulebase.js` [[erben|http://www.inztitut.de/blog/glossar/vererbung/]]. Im Unterordner `emphasis` sind einige der //Inline-Regeln// der Wikitext-Syntax definiert. Inline-Regeln erklären wir auch weiter unten.

</aside>



Um von einem Webbrowser dargestellt werden zu können, muss ~WikiText nach [[HTML|https://www.w3schools.com/html/default.asp]] konvertiert werden. Diese Aufgabe übernimmt TiddlyWiki´s interner Wikiparser.

Der Wikiparser wandelt den ~WikiText zuerst in einen //Parsebaum// (englisch: //Parsetree//) um. Dieser wird dann in einen //Widgetbaum// (englisch: //Widgettree//) konvertiert. Der erzeugt dann aus der Struktur seiner Daten das Html und die Javascript-Logik des Wikis. Die Widgets, aus denen er besteht, reagieren anschließend in Echtzeit auf die Benutzereingaben, für die sie zuständig sind.

Wir werden uns im folgenden hauptsächlich dem Prozess des Konvertierens von ~WikiText zum Parsebaum widmen und streifen den Widgetbaum nur kurz. Wie er arbeitet [[wird an anderer Stelle beschrieben|https://tiddlywiki.com/dev/#Widgets]].


<!-- ! Der Parsebaum-->

! Der Parsebaum

<!-- <aside class="info">-->

<aside class="info">

Ein anderes Wort für //Parsebaum// ist //AST// -- //abstract syntax tree// (deutsch: //Abstrakter Syntax-Baum//).

</aside>

<aside class="info">

Tip: Wenn man das Plugin //Tools for exploring the internals of ~TiddlyWiki// installiert (siehe [[Control Panel|$:/ControlPanel]] → Plugins), kann man sich die Parse- und Widgetbäume des eingegebenen ~WikiTextes, sowie das generierte HTML in der Vorschau ansehen.

</aside>




Wenn der Wikiparser seine Arbeit vollendet hat, wird er einen __Parsebaum__ erzeugt haben.

Der Parsebaum ist eine __Liste__ von __Objekten__, die ihrerseits Kind-Parsebäume enthalten können.

Zum Beispiel erzeugt dieser ~WikiText ...

```
! Hallo Welt

Die Sonne scheint
```

... (vereinfacht) diesen Parsebaum:

<!-- <aside class="info">-->

<aside class="info">

`"` und `"` kennzeichnet //Zeichenketten//. Sie sind der für Text zuständige [[Datentyp|https://www.inf-schule.de/programmierung/imperativeprogrammierung/konzepteimp/datentypen/konzept_datentyp]] in Programmiersprachen.

`[` und `]` kennzeichnet //Listen von Dingen//. Hier eine Liste von drei Zeichenketten:

```
[
  "Hello",
  "Bonjour",
  "Hallo"
]
```

`{` und `}` kennzeichet //Objekte//. Ein Objekt ist eine Liste von eindeutigen //Schlüsseln//, denen //Werte// zugeordnet werden. Beispiel:

```
{
  "Autor"  :"Nille",
  "Wiki"   :"TiddlyWiki",
  "Sprache":"DE"
}
```

Auch `true` und `false` kommen in Parsebäumen vor -- Das sind die zwei Zustände des Datentyps //Bool// (benannt nach [[George Boole|https://de.wikipedia.org/wiki/George_Boole]]). Er dient als An/Aus-Schalter.

</aside>



```
[
    {
        "type": "element",
        "tag": "h1",
        "children": [
            {
                "type": "text",
                "text": "Hallo Welt"
            }
        ]
    },
    {
        "type": "element",
        "tag": "p",
        "children": [
            {
                "type": "text",
                "text": "Die Sonne scheint"
            }
        ]
    }
]
```

Alle Objekte haben mindestens einen __Schlüssel__ "type", der den Typ des aktuellen Objekts definiert. Obiger Parsebaum enthält zwei Typen von Objekt: Element-Objekte -- Sie erzeugen Element-Knoten im resultierenden [[DOM|https://de.wikipedia.org/wiki/Document_Object_Model]] -- und Text-Objekte -- Sie erzeugen Textknoten.

<!-- <aside class="info">-->
<!--
<aside class="info">

Geben Sie folgendes in die [[Browser-Konsole|https://de.wikipedia.org/wiki/Entwicklerwerkzeuge_in_Webbrowsern]] ein, um einen JSON-String ihres ~WikiText-Parsebaumes zu erhalten:

```
JSON.stringify(new $tw.Wiki().parseText( "text/vnd.tiddlywiki", "Hier Wiki Text einfügen" ).tree);
```

</aside>
-->


Objekte die Kinder haben besitzen einen Schlüssel "children" (deutsch: "Kinder"). Die Kinder werden in Listen verwaltet. Text-Objekte haben niemals Kinder.

<!-- <aside class="info">-->

<aside class="info">

Diese zwei Objekte sind gleich, die Leerzeichen sind unwichtig:

```
{'foo':'bar'}
```

```
{
    'foo' : 'bar'
}
```

</aside>



In obigem Code-Beispiel dienen übrigens __Leerzeichen__ außerhalb von __Zeichenketten__ nur der Lesbarkeit und sind ohne Bedeutung für [[das verarbeitende Programm|https://www.w3schools.com/js/]]. Im ~WikiText ist das anders. Dort haben Leerzeilen eine Bedeutung für den Parser. Dazu gleich mehr.

<!--
Obiger Parsebaum wird innerhalb von ~TiddlyWiki mittels [[Javascript|https://www.w3schools.com/js/]] weiterverarbeitet, könnte aber in dieser Struktur auch von jeder anderen Programmiersprache bearbeitet werden, da er problemlos nach [[JSON|http://www.json.org/]] konvertiert werden kann, ein universelles Datenaustausch-Format das die meisten Programmiersprachen verstehen.
-->

<!-- ! Der Widgetbaum-->

! Der Widgetbaum

<!-- <aside class="info">-->

<aside class="info">

[[Quellcode der Widgets|https://github.com/Jermolene/TiddlyWiki5/tree/master/core/modules/widgets]]. In der Datei `widget.js` ist der Widget Prototyp definiert. Die anderen Widgets erben von ihm.

</aside>



Aus dem Parsebaum wird ein //Widgetbaum// erzeugt, der, wie der Name schon sagt, aus //Widgets// besteht -- Objekten mit (später) erweiterten Fähigkeiten.

Zum Beispiel erzeugt obiger Parsebaum folgenden Widgetbaum:

```
{
    "type": "widget",
    "children": [
        {
            "type": "element",
            "tag": "h1",
            "children": [
                {
                    "type": "text",
                    "text": "Hallo Welt"
                }
            ]
        },
        {
            "type": "element",
            "tag": "p",
            "children": [
                {
                    "type": "text",
                    "text": "Die Sonne scheint"
                }
            ]
        }
    ]
}
```

In diesem Beispiel unterscheidet sich der Widgetbaum kaum vom Parsebaum. Es ist einfach ein Objekt vom Typ Widget, das als Kinder den Parsebaum enthält. In anderen Fällen gibt es mehr Unterschiede.


<!-- ! Warum gibt es in ~TiddlyWiki sowohl Parse- als auch Widgetbäume?-->

! Warum gibt es in ~TiddlyWiki sowohl Parse- als auch Widgetbäume?

Die Unterscheidung zwischen Parse- und Widgetbaum besteht, weil zum Zeitpunkt des Parsens noch nicht alle [[Variablen|Variables]] und [[Makrodefinitionen|Macro Definitions in WikiText]] bekannt sind. Nach dem Parsen sind diese bekannt und nun kann der Widgetbaum [[Makros|Macros]] und [[Transklusionen|Transclusion]] auflösen.

Der Parsebaum sammelt die Informationen und der Widgetbaum erzeugt und verwaltet mit diesen Informationen das Wiki.


<!-- ! Wie der Parsebaum erzeugt wird-->

! Wie der Parsebaum erzeugt wird

Wir wollen uns nun anschauen, wie der Parser aus ~WikiText einen Parsebaum erzeugt.

<!-- !! Textblöcke-->

!! Textblöcke

<!-- <aside class="info">-->

<aside class="info">

Drei Textblöcke

```
Textblock

Textblock mit
zwei Zeilen

Noch ein Textblock
```

</aside>



Bevor ~WikiText geparst wird, besteht er zunächst einmal einfach nur aus //Textblöcken// -- durch Leerzeilen getrennte Gruppen von Textzeilen. Der Wikiparser arbeitet den ~WikiText Textblock für Textblock ab.

Jeder Textblock wird in das zu ihm passende HTML konvertiert, zum Beispiel eine Überschrift, Liste, Tabelle, oder ein Textabsatz.


<!-- !! Regeln-->

!! Regeln

<!-- <aside class="info">-->

<aside class="info">

[[Quellcode der WikiText Syntax-Regeln|https://github.com/Jermolene/TiddlyWiki5/tree/master/core/modules/parsers/wikiparser/rules]]. Ein einfaches Beispiel hier ist [[die Regel für Überschriften|https://github.com/Jermolene/TiddlyWiki5/blob/master/core/modules/parsers/wikiparser/rules/heading.js]]

</aside>



Der Wikiparser besteht aus mehreren Mini-Parsern. Für jedes Wikisyntax-Element gibt es einen Mini-Parser. In ~TiddlyWiki-Lingua werden diese Mini-Parser //Regeln// genannt (englisch: //Rules//).

Es gibt zwei Typen von Regeln:

<!-- !!! Block-Regeln-->

!!! Block-Regeln

<!-- <aside class="info">-->

<aside class="info">

```
! Überschrift

* Liste

|Eine|schlichte|Tabelle|
```

</aside>



Block-Regeln parsen  Wiki-Syntax-//Block-Elemente//. Das sind zum Beispiel [[Überschriften|Headings in WikiText]], [[Listen|Lists in WikiText]], [[Tabellen|Tables in WikiText]] und andere.

<!-- <aside class="info">-->

<aside class="info">

```
* Wird als Liste erkannt

Wird * nicht als Liste erkannt
```

</aside>



Solche Block-Elemente müssen am Start eines Textblocks stehen um von einer Block-Regel erkannt zu werden. Tun sie das nicht, werden sie als einfacher Text geparst, da für sie keine Inline-Regel definiert ist (Siehe unten). Eine Ausnahme ist die Regel für html-Elemente. Dazu nachher mehr.


<!-- !!! Fallback Textabsatz-->

!!! Fallback Textabsatz

<!-- <aside class="info">-->

<aside class="info">

Dieser ~WikiText ...

```
Ein Textabsatz
```

... erzeugt folgendes HTML ...

```
<p>Ein Textabsatz</p>
```

</aside>


<!-- <aside class="info">-->

<aside class="info">

''Achtung:'' Wir verwenden die Begriffe //Textblock// und //Textabsatz// für verschiedene Dinge: //Textblock// für die durch Leerzeilen getrennten Textzeilen im //~WikiText//. //Textabsatz// für ein von `<p>` und `</p>` umschlossenes Element im erzeugten //HTML-Quelltext//.

</aside>



Wenn ein Textblock kein Wiki-Syntax-Block-Element ist, wird er zu einem //Textabsatz// konvertiert -- `<p>...</p>`. Das Parsebaum-Objekt eines Textabsatzes sieht so aus:

```
{
    "type": "element",
    "tag": "p",
    "children": []
}
```

Textabsätze sind also ein Fallback-Mechanismus wenn keine Block-Regel passt. Damit wird sichergestellt, daß jeder Textblock zu etwas konvertiert wird, was im resultierenden HTML hinter sich einen Zeilenumbruch erzeugt.

Auch die resultierenden Html-Elemente werden in HTML-Lingua Block-Elemente genannt.


<!-- !!! Inline-Regeln-->

!!! Inline-Regeln

<!-- <aside class="info">-->

<aside class="info">

```
* Liste mit ''Inline-Element''

Textabsatz mit __Inline-Element__
```

</aside>



Inline-Regeln (deutsch: //In-Zeile//) parsen ~WikiText //Inline-Elemente//. Das sind Syntax-Elemente //innerhalb// von Textblöcken. Zum Beispiel kursiver, fett gedruckter, unterstrichener Text, [[und weitere|Formatting in WikiText]].

Inline-Elemente erzeugen hinter sich keinen Zeilenumbruch. Sie sind im resultierenden Html immer Kinder von Block-Elementen.

Auch die resultierenden Html-Elemente werden in HTML-Lingua Inline-Elemente genannt.




<!-- !! Vor dem Parsen: Regeln initialisieren-->

!! Vor dem Parsen: Regeln initialisieren

<!-- <aside class="info">-->

<aside class="info">

```
B→! Hallo i→//Welt//

Wie i→''geht´s?''
```

`B→` = Block-Regel passt, `i→` = Inline-Regel passt

</aside>



Bevor der Parser startet, lässt er zuerst einmal jede Regel im ~WikiText das nächstgelegene Syntax-Element finden für das sie zuständig ist. Zuerst die Block-Regeln, dann die Inline-Regeln. Wir werden später noch einmal auf diesen Punkt zurückkommen.

<!-- <aside class="info">-->

<aside class="info">

//Null// ist einer der einfachsten Datentypen. Er bedeutet: //Nichts//. Er hat nur einen Wert: Null.

</aside>



Eine Regel die nichts findet wird auf //Null// gesetzt.

Von einer Regel die etwas findet sagen wir, //sie passt//.


<!-- !! Der Prozess des Parsens-->

!! Der Prozess des Parsens

Nun spaziert der Parser Textblock für Textblock durch den ~WikiText. Währenddessen merkt er sich immer die aktuelle Position im Text, die wir im folgenden //Zeiger// nennen (in der Seitenleiste im folgenden das `|`).

<!-- !!! Block-Elemente parsen-->

!!! Block-Elemente parsen

Am Anfang jedes neuen Textblocks prüft der Parser zuerst, ob eine der Block-Regeln an dieser Stelle passt.

<!-- <aside class="info">-->

<aside class="info">

Block-Regel passt:

```
|* Liste
```

```
* Liste|
```

```
<ul><li>Liste</li></ul>
```

</aside>



Wenn das der Fall ist, wird der entsprechende Teil-Parsebaum erzeugt und in den globalen Parsebaum eingefügt. Der Zeiger wird hinter das Suchresultat der Block-Regel gesetzt. Die Regel findet anschließend selbstständig das nächste Resultat im ~WikiText, //ohne// jedoch den Zeiger zu verschieben.

Dann mit dem Zeiger auf zum nächsten Textblock. Die dazwischenliegenden Leerzeilen werden weggeworfen.


<!-- !!! Fallback: Textabsatz erzeugen-->

!!! Fallback: Textabsatz erzeugen

<!-- <aside class="info">-->

<aside class="info">

Keine Block-Regel passt:

```
|Text
```

```
Text|
```

```
<p>Text</p>
```

</aside>



Wenn jedoch keine Block-Regel am Anfang des Textblocks passt, erzeugt der Parser den schon erwähnten Mini-Parsebaum für einen Absatz und fügt ihn in den globalen Parsebaum ein.

Anschließend versucht der Parser alle Inline-Regeln durch.


<!-- !!! Inline Regel parsen-->

!!! Inline Regel parsen

<!-- <aside class="info">-->

<aside class="info">

Inline-Regel passt:

```
|//kursiv//
```

```
//kursiv//|
```

```
<p><em>kursiv</em></p>
```

</aside>



Wenn eine Inline-Regel am Anfang des Textblocks passt, lässt der Parser diese den entsprechenden Mini-Parsebaum erzeugen und fügt den in die Liste der Kinder des eben erzeugten Absatz-Parsebaumes ein. Der Zeiger wird auch hier direkt hinter das Suchresultat der Inline-Regel gesetzt und auch hier findet die Regel nun selbstständig das nächste Resultat ohne den Zeiger zu verschieben.


<!-- !!! Alles andere wird zu Text-->

!!! Alles andere wird zu Text

<!-- <aside class="info">-->

<aside class="info">

Keine Inline-Regel passt am Anfang:

```
|Text //kursiv//
```

```
Text |//kursiv//
```

```
<p>Text ...</p>
```

</aside>



Wenn auch keine Inline-Regel an dieser Stelle passt, fügt der Parser den Text von hier bis zur nächsten passenden Inline-Regel im Textblock als Text in die Liste der Kinder des Absatz-Parsebaumes ein. Dann verschiebt er den Zeiger an den Anfang dieser Regel, wo es dann mit dem Inline-Parsen weitergeht.

<!-- <aside class="info">-->

<aside class="info">

Keine Inline-Regel passt am Ende:

```
Text //kursiv//| Text
```

```
Text //kursiv// Text|
```

```
<p>Text <em>kursiv</em> Text</p>
```

</aside>



Wenn bis zum Ende des Textblocks keine weitere Inline-Regel passt, dann wird der verbleibende Text des Texblocks in den Absatz-Parsebaum eingefügt. Der Zeiger wird ans Ende des Textblocks verschoben.



Und dann mit dem Zeiger auf zum nächsten Textblock.

Das wird solange durchgeführt, bis das Ende des Dokuments erreicht ist.




<!-- ! Pragmas-->

! Pragmas

<!-- <aside class="info">-->

<aside class="info">

Verschiedene Pragmas

```
\whitespace trim

Text
```

```
\import [[My Tiddler with Macros]]
```

```
\define foo()
bar
\end

<<foo>>
```

</aside>



Wir haben der Einfachheit bisher etwas unterschlagen:

Es gibt neben den Block-Regeln und den Inline-Regeln noch eine dritte Kategorie von Regeln. Diese sind zuständig für [[Pragmas|Pragma]].

Pragmas müssen immer am Start des Tiddlers stehen. Bevor der Parser, wie oben beschrieben, durch den ~WikiText wandert, schnipselt er die Pragmas mithilfe der Pragma-Regeln vom Start des WikiTexts weg und führt aus/merkt sich, was sie definieren.

Pragmas können Variablen importieren, Makros definieren und festlegen ob überflüssige Leerzeichen während des nachfolgenden Parsens entfernt werden sollen.


<!-- ! Das Parsen von HTML-Elementen-->

! Das Parsen von HTML-Elementen

<!-- <aside class="info">-->

<aside class="info">

Html im Wikitext

```
<foo><bar></bar></foo>
```

</aside>



Für das Parsen von in den ~WikiText eingefügtes [[html|HTML in WikiText]] ist die HTML-Regel zuständig. Sie ist ein Sonderfall, da sie sowohl Block- als auch Inline-Regel ist.

WikiText kann dank der HTML-Regel jede beliebig verschachtelte Html-Struktur parsen. Tatsächlich ist das gesamte Wiki, das Sie gerade betrachten, in ~WikiText erstellt.

<!-- !! Vor dem Parsen-->

!! Vor dem Parsen

<!-- <aside class="info">-->

<aside class="info">

```
B→<div>
i→<span>Text</span>
</div>

```

`B→` = HTML-Block-Regel passt, `i→` = HTML-Inline-Regel passt

</aside>



Wir haben vorhin gesagt, daß der Parser, bevor er startet, zuerst alle Regeln losschickt, um im ~WikiText das nächstgelegene passende Syntax-Element zu finden. Zuerst die Block-Regeln, dann die Inline-Regeln.

Zur Erinnerung, Block-Regeln erzeugen Html-Block-Elemente, die einen Zeilenumbruch  hinter sich erzeugen, Inline-Regeln erzeugen Html-Elemente, die keinen Zeilenumbruch hinter sich erzeugen, und die immer Kinder von Block-Elementen sind.

Da die HTML-Regel sowohl Block- als auch Inline-Html im ~WikiText finden muss, wird sie in beiden Durchläufen aufgerufen, sowohl als Block- als auch als Inline-Regel.

<!-- <aside class="info">-->

<aside class="info">

Öffnender Tag

```
<span>...
```

</aside>



Die HTML-Regel sucht tatsächlich nicht das ganze Element, sondern nur den öffnenden Tag.

<!-- <aside class="info">-->

<aside class="info">

Block- und Inline-html

```
<block>
</block>

<inline></inline>
```

</aside>



Wenn dieser Tag sich, wie jedes andere gültige ~WikiText-Block-Element, am Anfang eines Textblock befindet, ''und'' wenn sich direkt dahinter ein Zeilenumbruch befindet, dann passt die Block-Regel. Ansonsten die Inline-Regel.


<!-- !! Html innerhalb eines Textblocks parsen-->

!! Html innerhalb eines Textblocks parsen

<!-- <aside class="info">-->

<aside class="info">

Parsen eines Inline-Elements in einem Textabsatz

```
Text |<span>Text</span>
```

```
Text <span>Text</span>|
```

```
<p>Text <span>Text</span></p>
```

Parsen eines Inline-Elements in einer Liste

```
* Text |<span>Text</span>
```

```
* Text <span>Text</span>|
```

```
<ul><li>Text <span>Text</span></li></ul>
```

</aside>



Wenn nun später beim Parsen der Parser //innerhalb// eines Textblocks ein HTML-Element vorfindet, kann nur die Inline-Regel passen, weil das Element nicht am Start steht. Das Element wird in einen Teil-Parsebaum umgewandelt, dessen Schlüssel "isBlock" den Wert `false` hat.

Die Kinder des Elements werden //nur// mithilfe der Inline-Regeln geparst und dann in die "children"-Liste des Parsebaums des Elements eingefügt.

Beispielsweise würde aus dem ~WikiText `<span>click</span>` nach dem Parsen des Elements und seiner Kinder folgender (hier vereinfachter) Teil-Parsebaum entstehen:

```
{
    "type": "element",
    "tag": "span",
    "isBlock": false,
    "children": [
        {
            "type": "text",
            "text": "click"
        }
    ]
}
```

Dieser Parsebaum wird in den globalen Parsebaum eingefügt, als Kind des Block-Elements in er sich befindet.


<!-- !! Html am Start eines Textblocks parsen-->

!! Html am Start eines Textblocks parsen

<!-- <aside class="info">-->

<aside class="info">

Wird dieser ~WikiText...

```
<element>...
```

... ein Inline-Element ...

```
<p><element>...</element></p>
```

... oder Block-Element werden? 

```
<element>...</element>
```

</aside>



Wenn das html-Element am Start eines Textblocks steht, könnte das Element sowohl Inline- als auch Block-Element sein. Im ersten Fall würde es (wie alle Inline-Elemente am Start eines Textblocks) in einen Textabsatz gefasst, im zweiten Fall würde es direkt in den globalen Parsebaum eingefügt werden, ohne umfassenden Textabsatz.

<!-- !!! Inline-Elemente parsen-->

!!! Inline-Elemente parsen

<!-- <aside class="info">-->

<aside class="info">

Starttag parsen ...

```
|<span></span>
```

```
<span>|</span>
```

... kein Zeilenumbruch. Also kein Block-Element. Darum //p// erzeugen, ...

```
<p></p>
```

... inline parsen, ...

```
|<span></span>
```

```
<span></span>|
```

... und in das //p// einfügen:

```
<p><span></span></p>
```

</aside>



Schauen wir uns zuerst an, was passiert wenn das Element ein Inline-Element ist (kein Zeilenumbuch nach dem öffnenden Tag):

Wie üblich, werden zuerst alle Block-Regeln durchprobiert. Die HTML-Block-Regel passt nicht, weil nach dem Starttag kein Zeilenumbruch ist. Natürlich passt auch keine andere Block-Regel. Nun wird, wie üblich, als Fallback der Textabsatz erzeugt und in den globalen Parsebaum eingefügt. Dann werden die Inline-Regeln durchprobiert. Hier passt nun die HTML-Inline-Regel und es wird verfahren wie oben beschrieben bei Html //innerhalb// des Textblocks.


<!-- !!! Block-Elemente parsen-->

!!! Block-Elemente parsen

<!-- <aside class="info">-->

<aside class="info">

Starttag parsen ...

```
|<div>
</div>
```

```
<div>
|</div>
```

... Block-Element! Kein //p// erzeugen.

```
<div></div>
```

</aside>



Wenn aber die HTML-//Block//-Regel passt, weil nach dem öffnenden Tag ein Zeilenumbruch steht, wird //kein// Absatz erstellt.

Stattdessen wird der Parsetree für das Element erstellt, aber noch nicht die für die Kinder. Also zum Beispiel für ein //div// ...

```
{
    "type": "element",
    "tag": "div",
    "isBlock": true,
    "children": [ ]
}
```

<!-- !!!! Kinder von Block-Elementen parsen-->

!!!! Kinder von Block-Elementen parsen

<!-- <aside class="info">-->

<aside class="info">

Der folgende ~WikiText ...

```
<span>

Text

</span>
```

... erzeugt ungültiges Html (//span//´s dürfen keine Textabsätze enthalten) ...

```
<span><p>Text</p></span>
```

... während dieser ...

```
<div>

Text

</div>
```

... gültiges Html erzeugt (//div//´s dürfen Textabsätze enthalten):

```
<div><p>Text</p></div>
```

</aside>


<!-- <aside class="info">-->

<!--

<aside class="info">

//span//´s (englisch: //to span//, deutsch: //überspannen//) sind Inline-Elemente. Sie sind nur zur Verwendung innerhalb von Block-Elementen gedacht und dürfen selbst keine Block-Elemente enthalten.

//div//´s (englisch: //division//, deutsch: //Bereich//) ist hingegen ein Block-Element, es darf sowohl Inline- als auch Block-Elemente enthalten.

Alle ~WikiText Block-Elemente (inklusive Textabsätze) sind auch Blockelemente im HTML. Alle ~Wikitext Inline-Elemente sind auch Inline-Elemente im HTML.

</aside>

-->



Nun stellt sich die Frage, wie die Kinder parsen? Nur mit den Inline-Regeln? Oder, so wie auf globaler Ebene, zuerst mit den Block-Regeln und dann mit den Inline-Regeln?

Diese Frage ist relevant, denn wenn zuerst mit den Block-Regeln getestet wird, werden unter Umständen HTML-Block-Elemente erstellt werden.

Laut dem HTML5 Standard dürfen aber Inline-Elemente (zum Beispiel //span//) keine Block-Elemente enthalten (zum Beispiel //p//).

Wenn also unser Html-Element, das im ~WikiText am Anfang des Textblocks steht, ein //span// ist, dann sollen die Kinder nur mit den ~WikiText-Inline-Regeln getestet werden.

Wenn es aber ein //div// ist, sind auch die ~WikiText-Block-Regeln ok.

<!-- <aside class="info">-->

<aside class="info">

Ein Zeilenumbruch, Kinder werden nur mit Inline-Regeln geprüft:

```
<div>
Text
</div>
```

```
<div>Text</div>
```

Zwei Zeilenumbrüche, Kinder werden normal, mit Block- und Inline-Regeln geprüft. Absatz-Erzeugung inclusive:

```
<div>

Text

</div>
```

```
<div><p>Text</p></div>
```

</aside>



Der Parser führt also einen erneuten Test durch:

Folgt dem öffnenden Tag //nur ein// Zeilenumbruch, werden die Kinder nur mit den Inline-Regeln geprüft.

Folgen dem öffnenden Tag //zwei oder mehr// Zeilenumbrüche, werden ganz normal alle Kind-Textblöcke durchwandert, jeder Textblock wird zuerst von den Block-Regeln, dann von den Inline-Regeln geprüft. Textabsätze werden, da wo notwendig, erstellt.

In beiden Fällen werden die erfolgreich geparsten Kinder in die children-Liste des Eltern-Elements eingefügt und zu guter Letzt das Eltern-Element in den globalen Parsebaum.







Und damit wäre die Funktionsweise der HTML-Regel geklärt.

<!-- !! Testen Sie sich selbst-->

!! Testen Sie sich selbst

Versuchen Sie zu verstehen, warum folgender ~WikiText ...

```
<button>Hi</button>

<button>Hi</button>

<button>
Hi
</button>

<button>
Hi
</button>

<button>

Hi

</button>

<button>

Hi

</button>
```

... so aussieht:

<button>Hi</button>

<button>Hi</button>

<button>
Hi
</button>

<button>
Hi
</button>

<button>

Hi

</button>

<button>

Hi

</button>



<!-- ! Das Parsen von Standalone-HTML-Elementen-->

! Das Parsen von Standalone-HTML-Elementen

Folgendes Beispiel zeigt, wie Standalone-Elemente geparst werden:

```
<hr/>

<br>

<button/>
```

Das resultierende HTML ist:

```
<hr>

<br>

<button></button>
```

<aside class="info">

Die im HTML5-Standard definierten Void-Elemente:

area, base, br, col, command, embed, hr, img, input, keygen, link, meta, param, source, track, wbr

</aside>

Das //hr// und das //br// sind sogenannte [[Void-Elemente|https://www.w3.org/TR/2011/WD-html-markup-20110405/syntax.html#syntax-elements]]. Das sind Elemente, die laut HTML5-Standard keinen Inhalt haben dürfen und die folglich keinen schließenden Tag benötigen.

Der ~TiddlyWiki Parser erkennt diese Elemente. Sie können mit oder ohne `/` geschrieben werden. ~TiddlyWiki wird das `/` im resultierenden HTML weglassen und das Element ansonsten unverändert einfügen.

Andere als Void-Elemente, wie im obigen Beispiel der `<button/>` werden in ihr Äquivalent mit schließendem Tag umgewandelt.

<!-- !! Block- und Inline-Modus für Standalone-Elemente-->

!! Block- und Inline-Modus für Standalone-Elemente

Beachten Sie, daß keines der Elemente im letzten Beispiel in ein //p// gehüllt wurde:

Ein Standalone-Element dem ein Zeilenumbruch nachfolgt, wird (fast genau so) geparst als hätte man ...

```
<element>
</element>
```

... geschrieben. Was, wie wir bereits wissen, bedeutet, daß das Element von der HTML-//Block//regel verarbeitet wird und folglich in kein //p// gehüllt ist.

Wenn kein Zeilenumbruch hinter dem Standalone-Element ist, wird es (fast genau) so geparst, als hätte man ...

```
<element></element>
```

... geschrieben, was bedeutet, es wird von der HTML-//Inline//-Regel verarbeitet und somit in ein //p// gehüllt.

Sprich:

```
<foo/>

<bar/> baz
```

... erzeugt ...

```
<foo></foo>

<p><bar></bar> baz</p>
```


<!-- deaktiviert, nicht mehr benötigt.

!! Ein Gotcha mit Standalone-Elementen

Hier noch ein Gotcha, daß man kennen sollte. Angenommen, Sie schreiben:

```
\define mein-button()
<button/>
\end

<<mein-button>>
```

Hier definieren Sie ein Makro und rufen es anschließend auf. Wie sieht das resultierende HTML aus? Wider Erwarten ist es in ein //p// gehüllt:

```
<p><button></button></p>
```

Aber wieso? Verhindert der Zeilenumbruch nach dem `<button/>` das nicht, wie im letzten Kapitel behauptet?

Nein, denn dieser Zeilenumbruch wird aus technischen Gründen beim Parsen des `\end` konsumiert. Darum hat `<button/>` hier tatsächlich keinen Zeilenumbruch hinter sich.

Es gibt zwei Lösungen (falls Sie das //p// stört):

Erstens:

```
\define my-button()
<button>
</button>
\end

<<my-button>>
```

Wandeln Sie das Standalone-Element in eines mit öffnendem und schließendem Tag um, und fügen Sie dazwischen einen Zeilenumbruch ein. Dieser sorgt dafür, daß das Element im Blockmodus geparst wird und darum nicht in ein //p// gehüllt ist.

Zweitens:

```
\define my-button()
<button/>

\end

<<my-button>>
```

Fügen Sie einen zusätzlichen Zeilenumbruch hinter `<button/>` hinzu. Er wird nicht von `\end` konsumiert werden und darum wird der Button, wie im letzten Kapitel beschrieben, in kein //p// gehüllt.

In beiden Fällen erhalten Sie (fast) das gleiche HTML:

```
<button></button>
```

Das hier erwähnte Gotcha kann auch bei einer Transklusion vorkommen, wenn der transkludierte Tiddler nicht mit einem Zeilenumbruch endet.

-->

<!-- ! Fehlende schließende HTML-Tags-->

!! Fehlende schließende HTML-Tags

Wenn ihr eingegebener ~WikiText seltsame Dinge produziert, haben Sie vielleicht einen schließenden Tag vergessen:

```
<div>
<span>
</div>
```

... erzeugt ...

```
<div>
<span>
&lt;/div&gt;
</span></div>
```

Der Parser sucht hinter dem öffnenden Tag des //span//´s nach einem schließenden //span//-Tag, findet aber keinen. Auf dem Weg entdeckt er einen schließenden //div//-Tag, aber da innerhalb des //span//´s bis dahin kein öffnender //div//-Tag gefunden wurde, parst er den schließenden //div//-Tag als Text, sprich, er ersetzt die HTML-Metazeichen `<` und `>` mit `&lt;` und `&gt;` (//lower than// und //greater than//, deutsch: //kleiner als// und //größer als//) und fügt dann diesen Text in den Parsebaum ein. Schließlich erreicht der Parser das Ende des Dokuments, wo er dann mangels Alternativen das Ende sowohl des //span//- als auch des //div//-Elements annimmt und deren schließende Tags einfügt.

Um das gewünschte Ergebnis zu erhalten, schließen Sie das //span//:

```
<div>
<span></span>
</div>
```

<!-- ! Optionale schließende Tags in HTML5-->

!! Optionale schließende Tags in HTML5

HTML5 erlaubt für bestimmte Elemente, selbst wenn sie Kind-Elemente enthalten dürfen, [[daß sie nicht geschlossen werden müssen|https://html.spec.whatwg.org/multipage/syntax.html#optional-tags]]. Das ist neu in HTML5, in HTML4 war es nicht erlaubt.

Im Moment unterstützt ~TiddlyWiki diese Ausnahmen nicht.

Das bedeutet, wenn Sie ...

```
<ul>
    <li>Eigentlich sollte hinter mir ein schließender li tag sein
    <li>und auch hinter mir
</ul>
```

... schreiben, erhalten Sie nicht, wie vom Standard gefordert ...

```
<ul>
    <li>Eigentlich sollte hinter mir ein schließender li tag sein</li>
    <li>und auch hinter mir</li>
</ul>
```

... sondern ein eher krudes Ergebnis, vergleichbar zum Beispiel im vorherigen Kapitel.

Schließen Sie also im Moment bitte ihre Tags, wo notwendig. Das schon erwähnte Plugin //Tools for exploring the internals of ~TiddlyWiki// kann ihnen dabei helfen, das generiere HTML zu debuggen.


<!-- Outro-->
Damit beenden wir unser Beschreibung der Funktionsweise des Wikiparsers. Wir hoffen, daß Sie ihnen dabei geholfen hat, zu verstehen, welchen ~WikiText Sie schreiben müssen um valides Html zu erzeugen.

Viel Spass beim ~WikiTexten!

